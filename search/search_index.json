{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dauto","text":"<p>Solutions for commons issues on django and drf projects</p>"},{"location":"#description","title":"Description","text":"<p>This project is a collection of common solutions for django projects. It aims to assist developers who are working with django by providing tried-and-tested solutions to recurring issues and challenges. The strategies covered in this project span from basic to advanced topics, making it a versatile resource for both beginners and experienced django developers. It facilitates quick problem-solving in Django projects and significantly reduces development time and effort. With these solutions at hand, developers can focus more on other crucial aspects of their projects.</p>"},{"location":"#use-cases","title":"Use Cases","text":"<p>We think that cover from simple to complex can be useful in the module learning curve so... let's go \ud83d\ude80!!!</p>"},{"location":"#using-classes-dynamically","title":"Using classes dynamically","text":"<p>Asume tha we have a file in 'module/test.py' with the next code on it:</p> <pre><code># module/test.py\nclass TestClass:\n    ...\n</code></pre> <p>Now we need to be dynamically capable to create instances of <code>TestClass</code> without import directive. The <code>using</code> function inside <code>utils</code> can do the hard job for us.</p> <pre><code>from dauto.utils import using\n\nTestClass = using(\"module.main.TestClass\")\n\n# Now we have a TestClass type, lets create a TestClass instance\n\ninstance = TestClass()\n\n# done !!!\n</code></pre>"},{"location":"#make-functions-awaitable","title":"Make functions awaitable","text":"<p>For some reason we need turn a normal function into an <code>async</code> function then we can use the  <code>awaitable</code> decorator inside <code>utils</code></p> <pre><code>from dauto.utils import awaitable\nimport  asyncio\n\n@awaitable\ndef test_function():\n    print(\"Hello world\")\n\n\nasyncio.run(test_function()) # This work even without `async` syntax\n</code></pre>"},{"location":"#build-singletons","title":"Build singletons","text":"<p>Singletons are a common design pattern, a detail explanation can be found here.  The <code>singleton</code> function inside <code>utils</code> is our python implementation of that design pattern.</p> <pre><code>from dauto.utils import singleton\n\n@singleton\nclass Omniscient:\n    ...\n\n\na = Omniscient()\nb = Omniscient()\n\nprint(a is b) # Output: True\n</code></pre>"},{"location":"#configure-django-databases-based-on-urls","title":"Configure django databases based on urls","text":"<pre><code>from dauto.database import  database\nimport os\nDATABASES = {\n    \"default\": database(os.getenv(\"DATABASE_URL\"), conn_max_age=None, conn_health_checks=True),\n    \"test\": {\n        \"NAME\": \"test.sqlite3\",\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n    },\n}\n</code></pre>"},{"location":"#embed-admin-definitions-in-models","title":"Embed admin definitions in models","text":"<p>We can do it this way </p> <pre><code># app/model.py\nfrom django.db import  models\nfrom django.contrib import admin\n\n\nclass Poll(models.Model):\n    title = models.CharField(max_length=256)\n    description = models.TextField(null=True, blank=True)\n    active = models.BooleanField(default=False)\n\n    def __str__(self):\n        return self.title\n\n    class Admin(admin.ModelAdmin):\n        list_display = [\"title\", \"active\"]\n        search_fields = [\"title\"]\n</code></pre> <p>then on application config do</p> <pre><code>from django.apps import AppConfig as BaseConfig\n\n\nclass AppConfig(BaseConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"apps\"\n\n    def ready(self) -&gt; None:\n        from dauto.admin import register # \ud83d\udc48\n        from app import  models # \ud83d\udc48\n\n        register(models) # \ud83d\udc48\n</code></pre>"},{"location":"#avoid-circular-signal-call","title":"Avoid circular signal call","text":"<p>This happens when two signals call each other, how break the cicle can be tricky we do it for you</p> <pre><code>from django.db import models\nfrom django.db.models import signals\nfrom django.dispatch import receiver\n\nfrom dauto.signals import OutSignal\n\nclass A(models.Model):\n    ...\n\nclass B(models.Model):\n    a = models.ManyToManyField(A)\n\n@receiver(signals.post_save, sender=A)\ndef on_a_change(sender, instance, **kwargs):\n    for b in  instance.b_set.all():\n        b.update(**{})\n\n@receiver(signals.post_save, sender=B)\ndef on_b_change(sender, instance, **kwargs):\n    with OutSignal(signals.post_save, on_a_change, A ): # \ud83d\udc48 disconnect on_a_change for this code block\n        for a in  instance.a.all():\n            a.update(**{})\n</code></pre>"},{"location":"#model-permission-for-drf-function-base-views","title":"Model permission for DRF function base views","text":"<pre><code>from rest_framework import decorators\nfrom app.models import  SomeModel # \ud83d\udc48 Asume this exist\nfrom dauto.drf.permission import permissions_for\n\n@decorators.api_view([\"GET\", \"POST\"])\n@decorators.permission_classes(permissions_for(SomeModel))\ndef some_model_view(request):\n    ...\n</code></pre>"},{"location":"#custom-namespace-versioning","title":"Custom namespace versioning","text":"<pre><code># common/versioning.py\n\nfrom dauto.drf.versioning import CustomNamespaceVersioning\n\nclass SharpNamespaceVersioning(CustomNamespaceVersioning):\n    separator = \"#\"\n</code></pre> <pre><code># settings.py\nREST_FRAMEWORK = {\n    \"DEFAULT_VERSIONING_CLASS\": \"common.versioning.SharpNamespaceVersioning\",\n}\n</code></pre> <p>Now your views can be reversed using <code>someview-details#v1</code></p>"},{"location":"#custom-serializers-getters-for-generic-viewsets","title":"Custom serializers getters for generic viewsets","text":"<p>Can be used to retrieve serializers based on operations</p> <p><pre><code>from dauto.drf.viewsets.mixin import ByOperationSerializerMixin\nfrom rest_framework.viewsets import ModelViewSet\nfrom rest_framework import decorators\nfrom app.serializers import AReadSerializer, AWriteSerializer, CustomOppSerializer\n\nclass AViewSet(ByOperationSerializerMixin, ModelViewSet):\n\n    @decorators.action([\"POST\"], detail=True)\n    def custom_opp(self, request): # will user serialize with key `custom_app` and fallback to 'write' key serializer \n        # if not found because is a 'POST' an operation that write on the DB\n        ...\n\n    serializer_class = {\n        \"read\": AReadSerializer,\n        \"write\": AWriteSerializer,\n        \"custom_opp\": CustomOppSerializer\n    }\n</code></pre> or retrieve serializers based on versions</p> <pre><code>from dauto.drf.viewsets.mixin import ByVersionSerializerMixin\nfrom rest_framework.viewsets import ModelViewSet\nfrom app.serializers import AReadSerializerV1, AWriteSerializerV2\n\nclass AViewSet(ByVersionSerializerMixin, ModelViewSet):\n\n    serializer_class = {\n        \"v1\": AReadSerializerV1,\n        \"v2\": AWriteSerializerV2,\n    }\n</code></pre> <p>Then the <code>AViewSet</code> class can be used in two separated versions (namespace, url, whatever) and use different serializers for any of these version keeping the logic without change.</p> <p>We can use combinations of both for different effects</p> <pre><code>from dauto.drf.viewsets.mixin import ByVersionSerializerMixin, ByOperationSerializerMixin\nfrom rest_framework.viewsets import ModelViewSet\nfrom app import serializers\n\nclass AViewSet(ByOperationSerializerMixin, ByVersionSerializerMixin, ModelViewSet):\n\n    serializer_class = {\n        \"v1\": {\n            \"read\": serializers.v1.AReadSerializer,\n            \"write\": serializers.v1.AWriteSerializer\n        },\n        \"v2\": {\n            \"read\": serializers.v2.AReadSerializer,\n            \"write\": serializers.v2.AWriteSerializer\n        },\n    }\n</code></pre>"},{"location":"#verbose-creation-and-update-methods","title":"Verbose creation and update methods","text":"<p>When we say verbose we refer to use a read serializer like to process the instance created. This make good combination with serializer getters</p> <p><pre><code>from dauto.drf.viewsets.mixin import ByVersionSerializerMixin, ByOperationSerializerMixin\nfrom dauto.drf.viewsets.mixin import CreateVerboseModelMixin, UpdateVerboseModelMixin\n\nfrom rest_framework.viewsets import  GenericViewSet\nfrom rest_framework import mixins\nfrom app import serializers\n\nclass AViewSet(\n    CreateVerboseModelMixin, # \ud83d\udc48\n    mixins.RetrieveModelMixin,\n    UpdateVerboseModelMixin, # \ud83d\udc48\n    mixins.DestroyModelMixin,\n    mixins.ListModelMixin,\n    ByOperationSerializerMixin, # \ud83d\udc48\n    ByVersionSerializerMixin, # \ud83d\udc48\n    GenericViewSet\n):\n\n    serializer_class = {\n        \"v1\": {\n            \"read\": serializers.v1.AReadSerializer,\n            \"write\": serializers.v1.AWriteSerializer\n        },\n        \"v2\": {\n            \"read\": serializers.v2.AReadSerializer,\n            \"write\": serializers.v2.AWriteSerializer\n        },\n    }\n</code></pre> Even if you use your own serializer system to get a writer and read serializer it will work, and use the serializer defined to be obtained in a read method as the verbose one.</p> <p>I think this cover all the project, happy coding \ufe0f \u263a\ufe0f\ud83d\udc4b</p>"},{"location":"dauto/admin/","title":"Administration Site","text":"<pre><code>import inspect\nfrom django.db.models import Model\nfrom django.contrib import admin\n</code></pre> <p>This IS NOT a  module/guide to make your administration site more beautiful, useful or user-friendly. This is a guide to do a 'better' setups of admin classes.  What this mean? We aim to encapsulate each admin class definition inside his target model (because one is meaningless without the other) then with the following method and the model container/module path we can dynamically set up the administration site.</p> <p></p> <pre><code>def register(container):\n</code></pre> Docstring <p>Registers models with the admin interface.</p> <p>Parameters: container: A container object which holds the model classes to be registered.</p> <pre><code>    for _, klass in inspect.getmembers(container):\n        if (\n                inspect.isclass(klass)\n                and issubclass(klass, Model)\n                and getattr(klass, \"Admin\", False)\n                and issubclass(klass.Admin, admin.ModelAdmin)\n        ):\n</code></pre> <pre><code>            try:\n                admin.register(klass)(getattr(klass, \"Admin\"))\n            except Exception:\n                print(f\"Model {klass.__name__} tried to be on admin but was ignored.\")\n</code></pre>"},{"location":"dauto/database/","title":"Database","text":"<pre><code>import urllib.parse as urlparse\n</code></pre> <p>When we deploy Django projects usually we get the database url as a configuration string so it's tricky destructure that configuration string in a proper database configuration for django. This module try to cover that for you.</p> <p>We start registering database common schemes in URLs like objects.</p> <pre><code>urlparse.uses_netloc.append(\"postgres\")\nurlparse.uses_netloc.append(\"mysql\")\nurlparse.uses_netloc.append(\"sqlite\")\n</code></pre> <p>Then we do a mapping of most used (a very opinionated stuff, We know) django database backends</p> <pre><code>SCHEMES = {\n    \"postgres\": \"django.db.backends.postgresql\",\n    \"mysql\": \"mysql.connector.django\",\n    \"sqlite\": \"django.db.backends.sqlite3\",\n}\n</code></pre> <p>Then we build the magic method that with a very few parameters alongside the url configuration return a valid django configuration for databases.</p> <p></p> <pre><code>def database(url, engine=None, conn_max_age=0, conn_health_checks=False, **options):\n</code></pre> Docstring <p>The <code>database</code> method is used to parse a database URL and return a configuration dictionary for connecting to the database.</p> <p>Parameters: url (string): The URL of the database to connect to. engine (string, optional): The database engine to use. Defaults to <code>None</code>. conn_max_age (int, optional): The maximum age of database connections in seconds. Defaults to <code>0</code>. conn_health_checks (bool, optional): Indicates whether to perform health checks on database connections. Defaults to <code>False</code>. **options (dict, optional): Additional database connection options. These will be added to the configuration dictionary.</p> <p>Returns: config (dict): The configuration dictionary for connecting to the database.</p> <pre><code>    if url == \"sqlite://:memory:\":\n</code></pre> <p>this is a special case, because if we pass this URL into urlparse, urlparse will choke trying to interpret \"memory\" as a port number</p> <pre><code>        return {\"ENGINE\": SCHEMES[\"sqlite\"], \"NAME\": \":memory:\"}\n</code></pre> <p>note: no other settings are required for sqlite</p> <p>otherwise parse the url as normal</p> <pre><code>    config = {}\n\n    url = urlparse.urlparse(url)\n</code></pre> <p>Split query strings from path.</p> <pre><code>    path = url.path[1:]\n    if \"?\" in path and not url.query:\n        path, query = path.split(\"?\", 2)\n    else:\n        path, query = path, url.query\n    query = urlparse.parse_qs(query)\n</code></pre> <p>If we are using sqlite, and we have no path, then assume we want an in-memory database (this is the behaviour of sqlalchemy)</p> <pre><code>    if url.scheme == \"sqlite\" and path == \"\":\n        path = \":memory:\"\n</code></pre> <p>Handle postgres percent-encoded paths.</p> <pre><code>    hostname = url.hostname or \"\"\n    if \"%2f\" in hostname.lower():\n</code></pre> <p>Switch to url.netloc to avoid lower cased paths</p> <pre><code>        hostname = url.netloc\n        if \"@\" in hostname:\n            hostname = hostname.rsplit(\"@\", 1)[1]\n        if \":\" in hostname:\n            hostname = hostname.split(\":\", 1)[0]\n        hostname = hostname.replace(\"%2f\", \"/\").replace(\"%2F\", \"/\")\n</code></pre> <p>Lookup specified engine.</p> <pre><code>    engine = SCHEMES[url.scheme] if engine is None else engine\n\n    port = url.port\n</code></pre> <p>Update with environment configuration.</p> <pre><code>    config.update(\n        {\n            \"NAME\": urlparse.unquote(path or \"\"),\n            \"USER\": urlparse.unquote(url.username or \"\"),\n            \"PASSWORD\": urlparse.unquote(url.password or \"\"),\n            \"HOST\": hostname,\n            \"PORT\": port or \"\",\n            \"CONN_MAX_AGE\": conn_max_age,\n            \"CONN_HEALTH_CHECKS\": conn_health_checks\n        }\n    )\n\n    for key, values in query.items():\n        if url.scheme == \"mysql\" and key == \"ssl-ca\":\n            options[\"ssl\"] = {\"ca\": values[-1]}\n            continue\n\n        options[key] = values[-1]\n</code></pre> <p>Support for Postgres Schema URLs</p> <pre><code>    if \"currentSchema\" in options and engine == \"django.db.backends.postgresql\":\n        options[\"options\"] = \"-c search_path={0}\".format(options.pop(\"currentSchema\"))\n\n    if options:\n        config[\"OPTIONS\"] = options\n\n    if engine:\n        config[\"ENGINE\"] = engine\n\n    return config\n</code></pre>"},{"location":"dauto/signals/","title":"Signals","text":"<p>Signals and circular calls sucks and when we use signals this happen frequently then we made a method for execute code  without a signal. This work with a python contex manager used as a pun so:</p> <pre><code>with OutSignal(signal,sender, receiver):\n    &lt;code&gt;\n</code></pre> <p>Will execute the <code>code</code> section with the signal unplugged, avoiding circular imports and nested signal calls</p> <p></p> <pre><code>class OutSignal:\n</code></pre> Docstring <p>This class represents a context manager for disconnecting and reconnecting signal handlers.</p> <pre><code>    def __init__(self, signal, receiver, sender, dispatch_uid=None):\n</code></pre> Docstring <p>Initializes an instance of the OutSignal class.</p> <p>Parameters: - signal: The signal object to be disconnected and reconnected. - receiver: The receiver object whose signal handler will be disconnected and reconnected. - sender: The sender object that will trigger the signal handler. - dispatch_uid: An optional unique identifier for the signal handler. If provided, only the signal handler with matching dispatch_uid will be disconnected and reconnected.</p> <pre><code>        self.signal = signal\n        self.receiver = receiver\n        self.sender = sender\n        self.dispatch_uid = dispatch_uid\n\n    def __enter__(self):\n        self.signal.disconnect(\n            receiver=self.receiver,\n            sender=self.sender,\n            dispatch_uid=self.dispatch_uid\n        )\n</code></pre> <pre><code>    def __exit__(self, type, value, traceback):\n        self.signal.connect(\n            receiver=self.receiver,\n            sender=self.sender,\n            dispatch_uid=self.dispatch_uid\n        )\n</code></pre>"},{"location":"dauto/drf/__init__/","title":"Django Rest Framework","text":"<p>Now more than ever APIS are fashionable with microservices, lambdas, serverless functions etc, and the framework (all least one of then ) for make APIS using Django is the Django Rest Framework. Thi section cover a sets of class extensions to this framework to solve common issues.</p>"},{"location":"dauto/drf/permission/","title":"Permissions","text":"<pre><code>import typing\nfrom django.db import models\nfrom rest_framework import permissions, exceptions\n\nM = typing.TypeVar(\"M\", bound=models.Model)\n</code></pre> <p>We want to add a more fancy way of adding model permission to a function base view in python. Starting for a class that use a model as a pivot to get the requiere permissions</p> <p></p> <pre><code>class _BaseApiFunctionViewModelPermissions(permissions.BasePermission):\n    model = None\n\n    perms_map = {\n        \"GET\": [],\n        \"OPTIONS\": [],\n        \"HEAD\": [],\n        \"POST\": [\"%(app_label)s.add_%(model_name)s\"],\n        \"PUT\": [\"%(app_label)s.change_%(model_name)s\"],\n        \"PATCH\": [\"%(app_label)s.change_%(model_name)s\"],\n        \"DELETE\": [\"%(app_label)s.delete_%(model_name)s\"],\n    }\n\n    authenticated_users_only = True\n\n    def get_required_permissions(self, method):\n</code></pre> Docstring <p>Given a models and an HTTP method, return the list of permission codes that the user is required to have.</p> <pre><code>        kwargs = {\n            \"app_label\": self.model._meta.app_label,\n            \"model_name\": self.model._meta.model_name,\n        }\n\n        if method not in self.perms_map:\n            raise exceptions.MethodNotAllowed(method)\n\n        return [perm % kwargs for perm in self.perms_map[method]]\n\n    def has_permission(self, request, view):\n</code></pre> <p>Workaround to ensure DjangoModelPermissions are not applied to the root view when using DefaultRouter.</p> <pre><code>        if getattr(view, \"_ignore_model_permissions\", False):\n            return True\n\n        if not request.user or (\n                not request.user.is_authenticated and self.authenticated_users_only\n        ):\n            return False\n\n        perms = self.get_required_permissions(request.method)\n\n        return request.user.has_perms(perms)\n</code></pre> <p>and then a function that can build other permission classes (not instances) using the previous class as base and the model as a parameter</p> <p></p> <pre><code>def permissions_for(model: typing.Generic[M]) -&gt; type:\n</code></pre> Docstring <p>Create a dynamic permission class for the given model.</p> <p>Parameters: model: The model object for which the permissions class is being generated.</p> <p>Returns: type: The dynamically created permission class.</p> <pre><code>    return type(\n        f\"{model.__class__.__name__}ModelPermission\",\n        (_BaseApiFunctionViewModelPermissions,),\n        locals(),\n    )\n</code></pre>"},{"location":"dauto/drf/versioning/","title":"Versioning","text":"<pre><code>from rest_framework.versioning import NamespaceVersioning\n</code></pre> <p>A namespace versioning to use when we want split into version an API</p> <p></p> <pre><code>class CustomNamespaceVersioning(NamespaceVersioning):\n</code></pre> Docstring <p>This class extends the NamespaceVersioning class and provides a custom implementation for versioning view names in a web application.</p> <pre><code>    separator: str | None = None\n</code></pre> <pre><code>    def get_versioned_viewname(self, viewname: str, request):\n        assert self.separator is not None\n        if self.separator in viewname:\n            view, version = viewname.split(self.separator, maxsplit=1)\n            return f\"{version}:{view}\"\n        return super().get_versioned_viewname(viewname, request)\n</code></pre>"},{"location":"dauto/drf/viewsets/mixin/","title":"Mixins","text":"<pre><code>from rest_framework import mixins, status, viewsets\nfrom rest_framework.response import Response\n</code></pre> <p>Django use mixins as a sort of dependency injection or inversion of control. This file contain a set of these dependencies implementations beforehand.</p>"},{"location":"dauto/drf/viewsets/mixin/#serializer-mixins","title":"Serializer mixins","text":"<p>The serializer mixins can 'inject' new ways to get serializers from classes, can be combined between them. They are self documented</p> <p></p> <pre><code>class ByOperationSerializerMixin:\n</code></pre> Docstring <p>This class is responsible for determining the appropriate serializer class based on the HTTP request method and the action being performed. It extends the GenericViewSet class.</p> <p></p> <pre><code>    def get_serializer_class(self: viewsets.GenericViewSet):\n        old: dict = super().get_serializer_class()\n        if hasattr(self, \"action\") and self.action in old:\n            return old.get(self.action)\n        elif self.request.method in [\"GET\", \"HEAD\", \"OPTIONS\"]:\n            return old.get(\"read\")\n        return old.get(\"write\")\n\n\nclass ByVersionSerializerMixin:\n</code></pre> Docstring <p>This class is responsible for determining the appropriate serializer class based on the request version.</p> <pre><code>    def get_serializer_class(self):\n        old: dict = super().get_serializer_class()\n        return old.get(self.request.version)\n</code></pre>"},{"location":"dauto/drf/viewsets/mixin/#verbose-mixins","title":"Verbose mixins","text":"<p>Many times we want a more verbose output from a write method (create, update, partial update) when we use DRF. The verbose mixins classes can do it using a read serializer to map the target instance into the desired format.</p> <p></p> <pre><code>class CreateVerboseModelMixin(mixins.CreateModelMixin):\n</code></pre> Docstring <p>This class is a mixin that extends the functionality of the CreateModelMixin class. It provides additional</p> <pre><code>    def get_read_object(self, instance):\n        return instance\n\n    def get_read_serializer(self, *args, **kwargs):\n</code></pre> Docstring <p>Return the serializer instance that should be used for validating and deserializing input, and for serializing output.</p> <pre><code>        method = self.request.method\n        self.request.method = \"GET\"\n        serializer_class = self.get_serializer_class()\n        self.request.method = method\n        kwargs.setdefault(\"context\", self.get_serializer_context())\n        return serializer_class(*args, **kwargs)\n\n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        read_serializer = self.get_read_serializer(self.get_read_object(serializer.instance))\n        return Response(\n            read_serializer.data, status=status.HTTP_201_CREATED, headers=headers\n        )\n</code></pre> <p></p> <pre><code>class UpdateVerboseModelMixin(mixins.UpdateModelMixin):\n</code></pre> Docstring <p>This class is a mixin that provides additional functionality for updating models with verbose output.</p> <pre><code>    def get_read_object(self, instance):\n        return instance\n\n    def get_read_serializer(self, *args, **kwargs):\n</code></pre> Docstring <p>Return the serializer instance that should be used for validating and deserializing input, and for serializing output.</p> <pre><code>        method = self.request.method\n        self.request.method = \"GET\"\n        serializer_class = self.get_serializer_class()\n        self.request.method = method\n        kwargs.setdefault(\"context\", self.get_serializer_context())\n        return serializer_class(*args, **kwargs)\n\n    def update(self, request, *args, **kwargs):\n        partial = kwargs.pop(\"partial\", False)\n        instance = self.get_object()\n        serializer = self.get_serializer(instance, data=request.data, partial=partial)\n        serializer.is_valid(raise_exception=True)\n        self.perform_update(serializer)\n        if getattr(instance, \"_prefetched_objects_cache\", None):\n</code></pre> <p>If 'prefetch_related' has been applied to a queryset, we need to forcibly invalidate the prefetch cache on the instance.</p> <pre><code>            instance._prefetched_objects_cache = {}\n        read_serializer = self.get_read_serializer(self.get_read_object(serializer.instance))\n        return Response(read_serializer.data)\n</code></pre>"},{"location":"dauto/utils/__init__/","title":"Utils","text":"<p>A set of utilities functions that solve commons issues not precisely related to Django. These are:</p> <ul> <li>dynamic import</li> <li>turn functions in coroutines</li> <li>make singleton classes</li> <li>an event bus system.</li> </ul> <pre><code>from .using import using\nfrom .awaitable import awaitable\nfrom .singleton import singleton\nfrom .events import Event, EventBuss\n\n__all__ = (\"using\", \"awaitable\", \"singleton\", \"Event\", \"EventBuss\")\n</code></pre>"},{"location":"dauto/utils/awaitable/","title":"dauto.utils.awaitable","text":"<pre><code>import functools\n\n\ndef awaitable(func):\n</code></pre> Docstring <p>Wrap a synchronous callable to allow <code>await</code>'ing it</p> <p>Parameters: func (callable): function to be converted to awaitable</p> <pre><code>    @functools.wraps(func)\n    async def coroutine(*args, **kwargs):\n        return func(*args, **kwargs)\n\n    return coroutine\n</code></pre>"},{"location":"dauto/utils/events/","title":"Events","text":"<pre><code>import typing\nimport functools\nimport asyncio\nimport inspect\nimport re\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom .awaitable import awaitable\n</code></pre> <p>We have been found a lot of events definitions over internet. This is one of them.</p> <p></p> <pre><code>_T = typing.TypeVar('_T')\n\n\n@dataclass(frozen=True)\nclass Event(typing.Generic[_T]):\n    topic: str\n    payload: _T\n    version: str | None = None\n    date: datetime.date = datetime.now()\n</code></pre> <p>Because we build the events system based on the observer pattern we need a sort of observer definition.</p> <p></p> <pre><code>class _Observer:\n    def __init__(self, topic, function: typing.Callable, version: str | None = None):\n        self._topic = re.compile(topic)\n        self._function = function\n        self._version = version\n        functools.update_wrapper(self, self._function)\n\n    @property\n    def topic(self):\n        return self._topic\n\n    @property\n    def version(self):\n        return self._version\n\n    def __call__(self, *args, **kwargs):\n        return self._function(*args, **kwargs)\n</code></pre> <p>Then the buss definition almost self-explanatory</p> <p></p> <pre><code>class EventBuss:\n    observers: typing.List[_Observer]\n\n    def __init__(self):\n        self.observers = []\n\n    def subscribe(self, topic: str, version: str | None = None):\n</code></pre> Docstring <p>This function return a decorator to subscribe a handler to an event topic and version.</p> <p>Parameters: topic (str): The topic to subscribe to. version (str): The version to subscribe to. Returns: callable: A decorator to subscribe to an event topic and version.</p> <pre><code>        def decorator(callback: typing.Callable[[Event], typing.Awaitable[typing.Any]]):\n            if not inspect.iscoroutinefunction(callback):\n                callback = awaitable(callback)\n            self.observers.append(_Observer(\n                topic.replace('.', '\\\\.').replace('*', '.*'),\n                callback,\n                version\n            ))\n            return callback\n\n        return decorator\n\n    async def _dispatch(self, event: Event):\n        coroutines = []\n        for callbacks in self.observers:\n            if callbacks.topic.fullmatch(event.topic):\n                coroutines.append(callbacks(event))\n        return await asyncio.gather(*coroutines)\n\n    def dispatch(self, event: Event):\n</code></pre> Docstring <p>Dispatch an event.</p> <p>Parameters: event (Event): The event to dispatch.</p> <pre><code>        return asyncio.run(self._dispatch(event))  # allow concurrent event handling\n</code></pre>"},{"location":"dauto/utils/singleton/","title":"dauto.utils.singleton","text":"<pre><code>import functools\n\n\ndef singleton(cls):\n</code></pre> Docstring <p>Make a class a singleton Parameters: cls (type): the class to be decorated</p> <pre><code>    @functools.wraps(cls)\n    def wrapper_singleton(*args, **kwargs):\n        if wrapper_singleton.instance is None:\n            wrapper_singleton.instance = cls(*args, **kwargs)\n        return wrapper_singleton.instance\n\n    wrapper_singleton.instance = None\n    return wrapper_singleton\n</code></pre>"},{"location":"dauto/utils/using/","title":"dauto.utils.using","text":"<pre><code>import importlib\n\n\ndef using(path: str):\n</code></pre> Docstring <p>Retrieve an attribute from a module.</p> <p>Parameters: path (str): The fully qualified path of the attribute, in the format 'module_name.class_name'.</p> <p>Returns: any: The attribute object.</p> <p>Raises: ImportError: If the module or class could not be imported.</p> <pre><code>    try:\n        module_name, class_name = path.rsplit('.', 1)\n        module = importlib.import_module(module_name)\n        return getattr(module, class_name)\n    except ImportError:\n        raise\n</code></pre>"}]}