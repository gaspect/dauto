{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dauto","text":"<p>Solutions for commons issues on django projects</p>"},{"location":"#description","title":"Description","text":"<p>This project is a collection of common solutions for Django projects. It aims to assist developers who are working with Django by providing tried-and-tested solutions to recurring issues and challenges. The strategies covered in this project span from basic to advanced topics, making it a versatile resource for both beginners and experienced Django developers. It facilitates quick problem-solving in Django projects and significantly reduces development time and effort. With these solutions at hand, developers can focus more on other crucial aspects of their projects.</p>"},{"location":"dauto/admin/","title":"Administration Site","text":"<pre><code>import inspect\nfrom django.db.models import Model\nfrom django.contrib import admin\n</code></pre> <p>This IS NOT a  module/guide to make your administration site more beautiful, useful or user-friendly. This is a guide to do a 'better' setups of admin classes.  What this mean? We aim to encapsulate each admin class definition inside his target model (because one is meaningless without the other) then with the following method and the model container/module path we can dynamically set up the administration site.</p> <p></p> <pre><code>def register(container):\n</code></pre> Docstring <p>Registers models with the admin interface.</p> <p>Parameters: container: A container object which holds the model classes to be registered.</p> <pre><code>    for _, klass in inspect.getmembers(container):\n        if (\n                inspect.isclass(klass)\n                and issubclass(klass, Model)\n                and getattr(klass, \"Admin\", False)\n                and issubclass(klass.Admin, admin.ModelAdmin)\n        ):\n</code></pre> <pre><code>            try:\n                admin.register(klass)(getattr(klass, \"Admin\"))\n            except Exception:\n                print(f\"Model {klass.__name__} tried to be on admin but was ignored.\")\n</code></pre>"},{"location":"dauto/database/","title":"Database","text":"<pre><code>import urllib.parse as urlparse\n</code></pre> <p>When we deploy Django projects usually we get the database url as a configuration string so it's tricky destructure that configuration string in a proper database configuration for django. This module try to cover that for you.</p> <p>We start registering database common schemes in URLs like objects.</p> <pre><code>urlparse.uses_netloc.append(\"postgres\")\nurlparse.uses_netloc.append(\"mysql\")\nurlparse.uses_netloc.append(\"sqlite\")\n</code></pre> <p>Then we do a mapping of most used (a very opinionated stuff, We know) django database backends</p> <pre><code>SCHEMES = {\n    \"postgres\": \"django.db.backends.postgresql\",\n    \"mysql\": \"mysql.connector.django\",\n    \"sqlite\": \"django.db.backends.sqlite3\",\n}\n</code></pre> <p>Then we build the magic method that with a very few parameters alongside the url configuration return a valid django configuration for databases.</p> <p></p> <pre><code>def database(url, engine=None, conn_max_age=0, conn_health_checks=False, **options):\n</code></pre> Docstring <p>The <code>database</code> method is used to parse a database URL and return a configuration dictionary for connecting to the database.</p> <p>Parameters: url (string): The URL of the database to connect to. engine (string, optional): The database engine to use. Defaults to <code>None</code>. conn_max_age (int, optional): The maximum age of database connections in seconds. Defaults to <code>0</code>. conn_health_checks (bool, optional): Indicates whether to perform health checks on database connections. Defaults to <code>False</code>. **options (dict, optional): Additional database connection options. These will be added to the configuration dictionary.</p> <p>Returns: config (dict): The configuration dictionary for connecting to the database.</p> <pre><code>    if url == \"sqlite://:memory:\":\n</code></pre> <p>this is a special case, because if we pass this URL into urlparse, urlparse will choke trying to interpret \"memory\" as a port number</p> <pre><code>        return {\"ENGINE\": SCHEMES[\"sqlite\"], \"NAME\": \":memory:\"}\n</code></pre> <p>note: no other settings are required for sqlite</p> <p>otherwise parse the url as normal</p> <pre><code>    config = {}\n\n    url = urlparse.urlparse(url)\n</code></pre> <p>Split query strings from path.</p> <pre><code>    path = url.path[1:]\n    if \"?\" in path and not url.query:\n        path, query = path.split(\"?\", 2)\n    else:\n        path, query = path, url.query\n    query = urlparse.parse_qs(query)\n</code></pre> <p>If we are using sqlite, and we have no path, then assume we want an in-memory database (this is the behaviour of sqlalchemy)</p> <pre><code>    if url.scheme == \"sqlite\" and path == \"\":\n        path = \":memory:\"\n</code></pre> <p>Handle postgres percent-encoded paths.</p> <pre><code>    hostname = url.hostname or \"\"\n    if \"%2f\" in hostname.lower():\n</code></pre> <p>Switch to url.netloc to avoid lower cased paths</p> <pre><code>        hostname = url.netloc\n        if \"@\" in hostname:\n            hostname = hostname.rsplit(\"@\", 1)[1]\n        if \":\" in hostname:\n            hostname = hostname.split(\":\", 1)[0]\n        hostname = hostname.replace(\"%2f\", \"/\").replace(\"%2F\", \"/\")\n</code></pre> <p>Lookup specified engine.</p> <pre><code>    engine = SCHEMES[url.scheme] if engine is None else engine\n\n    port = url.port\n</code></pre> <p>Update with environment configuration.</p> <pre><code>    config.update(\n        {\n            \"NAME\": urlparse.unquote(path or \"\"),\n            \"USER\": urlparse.unquote(url.username or \"\"),\n            \"PASSWORD\": urlparse.unquote(url.password or \"\"),\n            \"HOST\": hostname,\n            \"PORT\": port or \"\",\n            \"CONN_MAX_AGE\": conn_max_age,\n            \"CONN_HEALTH_CHECKS\": conn_health_checks\n        }\n    )\n\n    for key, values in query.items():\n        if url.scheme == \"mysql\" and key == \"ssl-ca\":\n            options[\"ssl\"] = {\"ca\": values[-1]}\n            continue\n\n        options[key] = values[-1]\n</code></pre> <p>Support for Postgres Schema URLs</p> <pre><code>    if \"currentSchema\" in options and engine == \"django.db.backends.postgresql\":\n        options[\"options\"] = \"-c search_path={0}\".format(options.pop(\"currentSchema\"))\n\n    if options:\n        config[\"OPTIONS\"] = options\n\n    if engine:\n        config[\"ENGINE\"] = engine\n\n    return config\n</code></pre>"},{"location":"dauto/signals/","title":"Signals","text":"<p>Signals and circular calls sucks and when we use signals this happen frequently then we made a method for execute code  without a signal. This work with a python contex manager used as a pun so:</p> <pre><code>with OutSignal(signal,sender, receiver):\n    &lt;code&gt;\n</code></pre> <p>Will execute the <code>code</code> section with the signal unplugged, avoiding circular imports and nested signal calls</p> <p></p> <pre><code>class OutSignal:\n</code></pre> Docstring <p>This class represents a context manager for disconnecting and reconnecting signal handlers.</p> <pre><code>    def __init__(self, signal, receiver, sender, dispatch_uid=None):\n</code></pre> Docstring <p>Initializes an instance of the OutSignal class.</p> <p>Parameters: - signal: The signal object to be disconnected and reconnected. - receiver: The receiver object whose signal handler will be disconnected and reconnected. - sender: The sender object that will trigger the signal handler. - dispatch_uid: An optional unique identifier for the signal handler. If provided, only the signal handler with matching dispatch_uid will be disconnected and reconnected.</p> <pre><code>        self.signal = signal\n        self.receiver = receiver\n        self.sender = sender\n        self.dispatch_uid = dispatch_uid\n\n    def __enter__(self):\n        self.signal.disconnect(\n            receiver=self.receiver,\n            sender=self.sender,\n            dispatch_uid=self.dispatch_uid\n        )\n</code></pre> <pre><code>    def __exit__(self, type, value, traceback):\n        self.signal.connect(\n            receiver=self.receiver,\n            sender=self.sender,\n            dispatch_uid=self.dispatch_uid\n        )\n</code></pre>"},{"location":"dauto/drf/__init__/","title":"Django Rest Framework","text":"<p>Now more than ever APIS are fashionable with microservices, lambdas, serverless functions etc, and the framework (all least one of then ) for make APIS using Django is the Django Rest Framework. Thi section cover a sets of class extensions to this framework to solve common issues.</p>"},{"location":"dauto/drf/permission/","title":"Permissions","text":"<pre><code>import typing\nfrom django.db import models\nfrom rest_framework import permissions, exceptions\n\nM = typing.TypeVar(\"M\", bound=models.Model)\n</code></pre> <p>We want to add a more fancy way of adding model permission to a function base view in python. Starting for a class that use a model as a pivot to get the requiere permissions</p> <p></p> <pre><code>class _BaseApiFunctionViewModelPermissions(permissions.BasePermission):\n    model = None\n\n    perms_map = {\n        \"GET\": [],\n        \"OPTIONS\": [],\n        \"HEAD\": [],\n        \"POST\": [\"%(app_label)s.add_%(model_name)s\"],\n        \"PUT\": [\"%(app_label)s.change_%(model_name)s\"],\n        \"PATCH\": [\"%(app_label)s.change_%(model_name)s\"],\n        \"DELETE\": [\"%(app_label)s.delete_%(model_name)s\"],\n    }\n\n    authenticated_users_only = True\n\n    def get_required_permissions(self, method):\n</code></pre> Docstring <p>Given a models and an HTTP method, return the list of permission codes that the user is required to have.</p> <pre><code>        kwargs = {\n            \"app_label\": self.model._meta.app_label,\n            \"model_name\": self.model._meta.model_name,\n        }\n\n        if method not in self.perms_map:\n            raise exceptions.MethodNotAllowed(method)\n\n        return [perm % kwargs for perm in self.perms_map[method]]\n\n    def has_permission(self, request, view):\n</code></pre> <p>Workaround to ensure DjangoModelPermissions are not applied to the root view when using DefaultRouter.</p> <pre><code>        if getattr(view, \"_ignore_model_permissions\", False):\n            return True\n\n        if not request.user or (\n                not request.user.is_authenticated and self.authenticated_users_only\n        ):\n            return False\n\n        perms = self.get_required_permissions(request.method)\n\n        return request.user.has_perms(perms)\n</code></pre> <p>and then a function that can build other permission classes (not instances) using the previous class as base and the model as a parameter</p> <p></p> <pre><code>def permissions_for(model: typing.Generic[M]) -&gt; type:\n</code></pre> Docstring <p>Create a dynamic permission class for the given model.</p> <p>Parameters: model: The model object for which the permissions class is being generated.</p> <p>Returns: type: The dynamically created permission class.</p> <pre><code>    return type(\n        f\"{model.__class__.__name__}ModelPermission\",\n        (_BaseApiFunctionViewModelPermissions,),\n        locals(),\n    )\n</code></pre>"},{"location":"dauto/drf/versioning/","title":"Versioning","text":"<pre><code>from rest_framework.versioning import NamespaceVersioning\n</code></pre> <p>A namespace versioning to use when we want split into version an API</p> <p></p> <pre><code>class CustomNamespaceVersioning(NamespaceVersioning):\n</code></pre> Docstring <p>This class extends the NamespaceVersioning class and provides a custom implementation for versioning view names in a web application.</p> <pre><code>    separator: str | None = None\n</code></pre> <pre><code>    def get_versioned_viewname(self, viewname: str, request):\n        assert self.separator is not None\n        if self.separator in viewname:\n            view, version = viewname.split(self.separator, maxsplit=1)\n            return f\"{version}:{view}\"\n        return super().get_versioned_viewname(viewname, request)\n</code></pre>"},{"location":"dauto/drf/viewsets/mixin/","title":"Mixins","text":"<pre><code>from rest_framework import mixins, status, viewsets\nfrom rest_framework.response import Response\n</code></pre> <p>Django use mixins as a sort of dependency injection or inversion of control. This file contain a set of these dependencies implementations beforehand.</p>"},{"location":"dauto/drf/viewsets/mixin/#serializer-mixins","title":"Serializer mixins","text":"<p>The serializer mixins can 'inject' new ways to get serializers from classes, can be combined between them. They are self documented</p> <p></p> <pre><code>class ByOperationSerializerMixin:\n</code></pre> Docstring <p>This class is responsible for determining the appropriate serializer class based on the HTTP request method and the action being performed. It extends the GenericViewSet class.</p> <p></p> <pre><code>    def get_serializer_class(self: viewsets.GenericViewSet):\n        old: dict = super().get_serializer_class()\n        if hasattr(self, \"action\") and self.action in old:\n            return old.get(self.action)\n        elif self.request.method in [\"GET\", \"HEAD\", \"OPTIONS\"]:\n            return old.get(\"read\")\n        return old.get(\"write\")\n\n\nclass ByVersionSerializerMixin:\n</code></pre> Docstring <p>This class is responsible for determining the appropriate serializer class based on the request version.</p> <pre><code>    def get_serializer_class(self):\n        old: dict = super().get_serializer_class()\n        return old.get(self.request.version)\n</code></pre>"},{"location":"dauto/drf/viewsets/mixin/#verbose-mixins","title":"Verbose mixins","text":"<p>Many times we want a more verbose output from a write method (create, update, partial update) when we use DRF. The verbose mixins classes can do it using a read serializer to map the target instance into the desired format.</p> <p></p> <pre><code>class CreateVerboseModelMixin(mixins.CreateModelMixin):\n</code></pre> Docstring <p>This class is a mixin that extends the functionality of the CreateModelMixin class. It provides additional</p> <pre><code>    def get_read_object(self, instance):\n        return instance\n\n    def get_read_serializer(self, *args, **kwargs):\n</code></pre> Docstring <p>Return the serializer instance that should be used for validating and deserializing input, and for serializing output.</p> <pre><code>        method = self.request.method\n        self.request.method = \"GET\"\n        serializer_class = self.get_serializer_class()\n        self.request.method = method\n        kwargs.setdefault(\"context\", self.get_serializer_context())\n        return serializer_class(*args, **kwargs)\n\n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        read_serializer = self.get_read_serializer(self.get_read_object(serializer.instance))\n        return Response(\n            read_serializer.data, status=status.HTTP_201_CREATED, headers=headers\n        )\n</code></pre> <p></p> <pre><code>class UpdateVerboseModelMixin(mixins.UpdateModelMixin):\n</code></pre> Docstring <p>This class is a mixin that provides additional functionality for updating models with verbose output.</p> <pre><code>    def get_read_object(self, instance):\n        return instance\n\n    def get_read_serializer(self, *args, **kwargs):\n</code></pre> Docstring <p>Return the serializer instance that should be used for validating and deserializing input, and for serializing output.</p> <pre><code>        method = self.request.method\n        self.request.method = \"GET\"\n        serializer_class = self.get_serializer_class()\n        self.request.method = method\n        kwargs.setdefault(\"context\", self.get_serializer_context())\n        return serializer_class(*args, **kwargs)\n\n    def update(self, request, *args, **kwargs):\n        partial = kwargs.pop(\"partial\", False)\n        instance = self.get_object()\n        serializer = self.get_serializer(instance, data=request.data, partial=partial)\n        serializer.is_valid(raise_exception=True)\n        self.perform_update(serializer)\n        if getattr(instance, \"_prefetched_objects_cache\", None):\n</code></pre> <p>If 'prefetch_related' has been applied to a queryset, we need to forcibly invalidate the prefetch cache on the instance.</p> <pre><code>            instance._prefetched_objects_cache = {}\n        read_serializer = self.get_read_serializer(self.get_read_object(serializer.instance))\n        return Response(read_serializer.data)\n</code></pre>"},{"location":"dauto/utils/__init__/","title":"Utils","text":"<p>A set of utilities functions that solve commons issues not precisely related to Django. These are:</p> <ul> <li>dynamic import</li> <li>turn functions in coroutines</li> <li>make singleton classes</li> <li>an event bus system.</li> </ul> <pre><code>from .using import using\nfrom .awaitable import awaitable\nfrom .singleton import singleton\nfrom .events import Event, EventBuss\n\n__all__ = (\"using\", \"awaitable\", \"singleton\", \"Event\", \"EventBuss\")\n</code></pre>"},{"location":"dauto/utils/awaitable/","title":"Awaitable","text":"<pre><code>import functools\n\n\ndef awaitable(func):\n</code></pre> Docstring <p>Wrap a synchronous callable to allow <code>await</code>'ing it</p> <p>@functools.wraps(func) async def coroutine(args, kwargs): return func(args, **kwargs)</p> <p>return coroutine</p>"},{"location":"dauto/utils/events/","title":"Events","text":"<pre><code>import typing\nimport functools\nimport asyncio\nimport inspect\nimport re\nfrom dataclasses import dataclass\nfrom datetime import datetime\nfrom .singleton import singleton\nfrom .awaitable import awaitable\n\n\n_T = typing.TypeVar('_T')\n\n\n@dataclass(frozen=True)\nclass Event(typing.Generic[_T]):\n    topic: str\n    payload: _T\n    version: str | None = None\n    date: datetime.date = datetime.now()\n\n\nclass _Observer:\n    def __init__(self, topic, function: typing.Callable):\n        self._topic = re.compile(topic)\n        self._function = function\n        functools.update_wrapper(self, self._function)\n\n    @property\n    def topic(self):\n        return self._topic\n\n    def __call__(self, *args, **kwargs):\n        return self._function(*args, **kwargs)\n\n\n@singleton\nclass EventBuss:\n    observers: typing.List[_Observer]\n\n    def __init__(self):\n        self.observers = []\n\n    def subscribe(self, topic: str):\n        def decorator(callback: typing.Callable[[Event], typing.Awaitable[typing.Any]]):\n            if not inspect.iscoroutinefunction(callback):\n                callback = awaitable(callback)\n            self.observers.append(_Observer(\n                topic.replace('.', '\\\\.').replace('*', '.*'),\n                callback\n            ))\n            return callback\n\n        return decorator\n\n    async def _dispatch(self, event: Event):\n        coroutines = []\n        for callbacks in self.observers:\n            if callbacks.topic.fullmatch(event.topic):\n                coroutines.append(callbacks(event))\n        return await asyncio.gather(*coroutines)\n\n    def dispatch(self, event: Event):\n        return asyncio.run(self._dispatch(event))  # allow concurrent event handling\n</code></pre>"},{"location":"dauto/utils/singleton/","title":"Singleton","text":"<pre><code>import functools\n\n\ndef singleton(cls):\n    @functools.wraps(cls)\n    def wrapper_singleton(*args, **kwargs):\n        if wrapper_singleton.instance is None:\n            wrapper_singleton.instance = cls(*args, **kwargs)\n        return wrapper_singleton.instance\n\n    wrapper_singleton.instance = None\n    return wrapper_singleton\n</code></pre>"},{"location":"dauto/utils/using/","title":"Using","text":"<pre><code>import importlib\n\n\ndef using(path: str):\n</code></pre> Docstring <p>Retrieve an attribute from a module.</p> <p>Parameters: path (str): The fully qualified path of the attribute, in the format 'module_name.class_name'.</p> <p>Returns: any: The attribute object.</p> <p>Raises: ImportError: If the module or class could not be imported.</p> <pre><code>    try:\n        module_name, class_name = path.rsplit('.', 1)\n        module = importlib.import_module(module_name)\n        return getattr(module, class_name)\n    except ImportError:\n        raise\n</code></pre>"}]}