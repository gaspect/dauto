{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Dauto","text":"<p>Solutions for commons issues on Django and drf projects</p>"},{"location":"#description","title":"Description","text":"<p>This project is a collection of common solutions for Django projects. It aims to assist developers who are working with Django by providing tried-and-tested solutions to recurring issues and challenges. The strategies covered in this project span from basic to advanced topics, making it a versatile resource for both beginners and experienced Django developers. It facilitates quick problem-solving in Django projects and significantly reduces development time and effort. With these solutions at hand, developers can focus more on other crucial aspects of their projects. To learn more read the documentation.</p>"},{"location":"#use-cases","title":"Use Cases","text":"<p>We think that cover from simple to complex can be useful in the module learning curve so... let's go \ud83d\ude80!!!</p>"},{"location":"#configure-django-databases-based-on-urls","title":"Configure django databases based on urls","text":"<pre><code>from dauto.database import  database\nimport os\nDATABASES = {\n    \"default\": database(os.getenv(\"DATABASE_URL\"), conn_max_age=None, conn_health_checks=True),\n    \"test\": {\n        \"NAME\": \"test.sqlite3\",\n        \"ENGINE\": \"django.db.backends.sqlite3\",\n    },\n}\n</code></pre>"},{"location":"#embed-admin-definitions-in-models","title":"Embed admin definitions in models","text":"<p>We can do it this way </p> <pre><code># app/model.py\nfrom django.db import  models\nfrom django.contrib import admin\n\n\nclass Poll(models.Model):\n    title = models.CharField(max_length=256)\n    description = models.TextField(null=True, blank=True)\n    active = models.BooleanField(default=False)\n\n    def __str__(self):\n        return self.title\n\n    class Admin(admin.ModelAdmin):\n        list_display = [\"title\", \"active\"]\n        search_fields = [\"title\"]\n</code></pre> <p>then on application config do</p> <pre><code>from django.apps import AppConfig as BaseConfig\n\n\nclass AppConfig(BaseConfig):\n    default_auto_field = \"django.db.models.BigAutoField\"\n    name = \"apps\"\n\n    def ready(self) -&gt; None:\n        from dauto.admin import register # \ud83d\udc48\n        from app import  models # \ud83d\udc48\n\n        register(models) # \ud83d\udc48\n</code></pre>"},{"location":"#avoid-circular-signal-call","title":"Avoid circular signal call","text":"<p>This happens when two signals call each other, how break the cicle can be tricky we do it for you</p> <pre><code>from django.db import models\nfrom django.db.models import signals\nfrom django.dispatch import receiver\n\nfrom dauto.signals import OutSignal\n\nclass A(models.Model):\n    ...\n\nclass B(models.Model):\n    a = models.ManyToManyField(A)\n\n@receiver(signals.post_save, sender=A)\ndef on_a_change(sender, instance, **kwargs):\n    for b in  instance.b_set.all():\n        b.update(**{})\n\n@receiver(signals.post_save, sender=B)\ndef on_b_change(sender, instance, **kwargs):\n    with OutSignal(signals.post_save, on_a_change, A ): # \ud83d\udc48 disconnect on_a_change for this code block\n        for a in  instance.a.all():\n            a.update(**{})\n</code></pre>"},{"location":"#model-permission-for-drf-function-base-views","title":"Model permission for DRF function base views","text":"<pre><code>from rest_framework import decorators\nfrom app.models import  SomeModel # \ud83d\udc48 Asume this exist\nfrom dauto.drf.permission import permissions_for\n\n@decorators.api_view([\"GET\", \"POST\"])\n@decorators.permission_classes(permissions_for(SomeModel))\ndef some_model_view(request):\n    ...\n</code></pre>"},{"location":"#custom-namespace-versioning","title":"Custom namespace versioning","text":"<pre><code># common/versioning.py\n\nfrom dauto.drf.versioning import CustomNamespaceVersioning\n\nclass SharpNamespaceVersioning(CustomNamespaceVersioning):\n    separator = \"#\"\n</code></pre> <pre><code># settings.py\nREST_FRAMEWORK = {\n    \"DEFAULT_VERSIONING_CLASS\": \"common.versioning.SharpNamespaceVersioning\",\n}\n</code></pre> <p>Now your views can be reversed using <code>someview-details#v1</code></p>"},{"location":"#custom-serializers-getters-for-generic-viewsets","title":"Custom serializers getters for generic viewsets","text":"<p>Can be used to retrieve serializers based on operations</p> <p><pre><code>from dauto.drf.viewsets.mixin import ByOperationSerializerMixin\nfrom rest_framework.viewsets import ModelViewSet\nfrom rest_framework import decorators\nfrom app.serializers import AReadSerializer, AWriteSerializer, CustomOppSerializer\n\nclass AViewSet(ByOperationSerializerMixin, ModelViewSet):\n\n    @decorators.action([\"POST\"], detail=True)\n    def custom_opp(self, request): # will user serialize with key `custom_app` and fallback to 'write' key serializer \n        # if not found because is a 'POST' an operation that write on the DB\n        ...\n\n    serializer_class = {\n        \"read\": AReadSerializer,\n        \"write\": AWriteSerializer,\n        \"custom_opp\": CustomOppSerializer\n    }\n</code></pre> or retrieve serializers based on versions</p> <pre><code>from dauto.drf.viewsets.mixin import ByVersionSerializerMixin\nfrom rest_framework.viewsets import ModelViewSet\nfrom app.serializers import AReadSerializerV1, AWriteSerializerV2\n\nclass AViewSet(ByVersionSerializerMixin, ModelViewSet):\n\n    serializer_class = {\n        \"v1\": AReadSerializerV1,\n        \"v2\": AWriteSerializerV2,\n    }\n</code></pre> <p>Then the <code>AViewSet</code> class can be used in two separated versions (namespace, url, whatever) and use different serializers for any of these version keeping the logic without change.</p> <p>We can use combinations of both for different effects</p> <pre><code>from dauto.drf.viewsets.mixin import ByVersionSerializerMixin, ByOperationSerializerMixin\nfrom rest_framework.viewsets import ModelViewSet\nfrom app import serializers\n\nclass AViewSet(ByOperationSerializerMixin, ByVersionSerializerMixin, ModelViewSet):\n\n    serializer_class = {\n        \"v1\": {\n            \"read\": serializers.v1.AReadSerializer,\n            \"write\": serializers.v1.AWriteSerializer\n        },\n        \"v2\": {\n            \"read\": serializers.v2.AReadSerializer,\n            \"write\": serializers.v2.AWriteSerializer\n        },\n    }\n</code></pre>"},{"location":"#verbose-creation-and-update-methods","title":"Verbose creation and update methods","text":"<p>When we say verbose we refer to use a read serializer like to process the instance created. This make good combination with serializer getters</p> <pre><code>from dauto.drf.viewsets.mixin import ByVersionSerializerMixin, ByOperationSerializerMixin\nfrom dauto.drf.viewsets.mixin import CreateVerboseModelMixin, UpdateVerboseModelMixin\n\nfrom rest_framework.viewsets import  GenericViewSet\nfrom rest_framework import mixins\nfrom app import serializers\n\nclass AViewSet(\n    CreateVerboseModelMixin, # \ud83d\udc48\n    mixins.RetrieveModelMixin,\n    UpdateVerboseModelMixin, # \ud83d\udc48\n    mixins.DestroyModelMixin,\n    mixins.ListModelMixin,\n    ByOperationSerializerMixin, # \ud83d\udc48\n    ByVersionSerializerMixin, # \ud83d\udc48\n    GenericViewSet\n):\n\n    serializer_class = {\n        \"v1\": {\n            \"read\": serializers.v1.AReadSerializer,\n            \"write\": serializers.v1.AWriteSerializer\n        },\n        \"v2\": {\n            \"read\": serializers.v2.AReadSerializer,\n            \"write\": serializers.v2.AWriteSerializer\n        },\n    }\n</code></pre> <p>Even if you use your own serializer system to get a writer and read serializer it will work, and use the serializer defined to be obtained in a read method as the verbose one.</p>"},{"location":"#polymorphic-useful-methods","title":"Polymorphic useful methods","text":"<p>If you've never read about django polymorphic start here. Is a  more (debated) way to handle model inheritance. That method have its own caveats and drawbacks that we try to fix. One of then is incompatibility with some django  core admin functions making the django administration site useless, can be fixed using the <code>dauto.polymorphic.collector</code> function.</p> <p>In this example the user model is, and it's related with polymorphic models, so we need to monkey patch some django inners methods to solve incompatibility (do not ask how many hours or debug took give with the answer).</p> <p><pre><code>from django.contrib.auth.admin import UserAdmin\n\nfrom django.contrib.admin import utils #\ud83d\udc48\nfrom django.db.models import deletion #\ud83d\udc48\n\n\nfrom dauto.polymorphic import collector\n\nclass CustomUserModelAdmin(UserAdmin):\n\n    def get_deleted_objects(self, objs, request):\n        with collector(utils.NestedObjects): #\ud83d\udc48\n            return super().get_deleted_objects(objs, request) # now this method use the monkey patched object\n        # and here the object back to normality\n\n    def delete_queryset(self, request, queryset):\n        with collector(deletion.Collector): #\ud83d\udc48\n            return super().delete_queryset(request, queryset) # now this method use the monkey patched object\n        # and here the object back to normality\n</code></pre> We also build a method to build polymorphic serializers using already existing serializers. Can be found as the <code>dauto.polymorphic.polymorphic</code> function.</p> <p>I think this cover all the project, happy coding \ufe0f \u263a\ufe0f\ud83d\udc4b</p>"},{"location":"dauto/__init__/","title":"init","text":"<pre><code>try:\n    import django\nexcept ImportError as e:\n    raise ImportError(\"You must install 'django' or dauto[django] packages to use this package.\")\n</code></pre>"},{"location":"dauto/admin/","title":"Administration Site","text":"<pre><code>import inspect\nfrom django.db.models import Model\nfrom django.contrib import admin\n</code></pre> <p>This IS NOT a  module/guide to make your administration site more beautiful, useful or user-friendly. This is a guide to do a 'better' setups of admin classes.  What this mean? We aim to encapsulate each admin class definition inside his target model (because one is meaningless without the other) then with the following method and the model container/module path we can dynamically set up the administration site.</p> <p></p> <pre><code>def register(container):\n</code></pre> Docstring <p>Registers models with the admin interface.</p> <p>Parameters: container: A container object which holds the model classes to be registered.</p> <pre><code>    for _, klass in inspect.getmembers(container):\n        if (\n                inspect.isclass(klass)\n                and issubclass(klass, Model)\n                and getattr(klass, \"Admin\", False)\n                and issubclass(klass.Admin, admin.ModelAdmin)\n        ):\n</code></pre> <pre><code>            try:\n                admin.register(klass)(getattr(klass, \"Admin\"))\n            except Exception:\n                print(f\"Model {klass.__name__} tried to be on admin but was ignored.\")\n</code></pre>"},{"location":"dauto/database/","title":"Database","text":"<pre><code>import urllib.parse as urlparse\n</code></pre> <p>When we deploy Django projects usually we get the database url as a configuration string so it's tricky destructure that configuration string in a proper database configuration for django. This module try to cover that for you.</p> <p>We start registering database common schemes in URLs like objects.</p> <pre><code>urlparse.uses_netloc.append(\"postgres\")\nurlparse.uses_netloc.append(\"mysql\")\nurlparse.uses_netloc.append(\"sqlite\")\n</code></pre> <p>Then we do a mapping of most used (a very opinionated stuff, We know) django database backends</p> <pre><code>SCHEMES = {\n    \"postgres\": \"django.db.backends.postgresql\",\n    \"mysql\": \"django.db.backends.mysql\",\n    \"sqlite\": \"django.db.backends.sqlite3\",\n    \"oracle\": \"django.db.backends.oracle\"\n}\n</code></pre> <p>Then we build the magic method that with a very few parameters alongside the url configuration return a valid django configuration for databases.</p> <p></p> <pre><code>def database(url, engine=None, conn_max_age=0, conn_health_checks=False, **options):\n</code></pre> Docstring <p>The <code>database</code> method is used to parse a database URL and return a configuration dictionary for connecting to the database.</p> <p>Parameters: url (string): The URL of the database to connect to. engine (string, optional): The database engine to use. Defaults to <code>None</code>. conn_max_age (int, optional): The maximum age of database connections in seconds. Defaults to <code>0</code>. conn_health_checks (bool, optional): Indicates whether to perform health checks on database connections. Defaults to <code>False</code>. **options (dict, optional): Additional database connection options. These will be added to the configuration dictionary.</p> <p>Returns: config (dict): The configuration dictionary for connecting to the database.</p> <pre><code>    if url == \"sqlite://:memory:\":\n</code></pre> <p>this is a special case, because if we pass this URL into urlparse, urlparse will choke trying to interpret \"memory\" as a port number</p> <pre><code>        return {\"ENGINE\": SCHEMES[\"sqlite\"], \"NAME\": \":memory:\"}\n</code></pre> <p>note: no other settings are required for sqlite</p> <p>otherwise parse the url as normal</p> <pre><code>    config = {}\n\n    url = urlparse.urlparse(url)\n</code></pre> <p>Split query strings from path.</p> <pre><code>    path = url.path[1:]\n    if \"?\" in path and not url.query:\n        path, query = path.split(\"?\", 2)\n    else:\n        path, query = path, url.query\n    query = urlparse.parse_qs(query)\n</code></pre> <p>If we are using sqlite, and we have no path, then assume we want an in-memory database (this is the behaviour of sqlalchemy)</p> <pre><code>    if url.scheme == \"sqlite\" and path == \"\":\n        path = \":memory:\"\n</code></pre> <p>Handle postgres percent-encoded paths.</p> <pre><code>    hostname = url.hostname or \"\"\n    if \"%2f\" in hostname.lower():\n</code></pre> <p>Switch to url.netloc to avoid lower cased paths</p> <pre><code>        hostname = url.netloc\n        if \"@\" in hostname:\n            hostname = hostname.rsplit(\"@\", 1)[1]\n        if \":\" in hostname:\n            hostname = hostname.split(\":\", 1)[0]\n        hostname = hostname.replace(\"%2f\", \"/\").replace(\"%2F\", \"/\")\n</code></pre> <p>Lookup specified engine.</p> <pre><code>    engine = SCHEMES[url.scheme] if engine is None else engine\n\n    port = url.port\n</code></pre> <p>Update with environment configuration.</p> <pre><code>    config.update(\n        {\n            \"NAME\": urlparse.unquote(path or \"\"),\n            \"USER\": urlparse.unquote(url.username or \"\"),\n            \"PASSWORD\": urlparse.unquote(url.password or \"\"),\n            \"HOST\": hostname,\n            \"PORT\": port or \"\",\n            \"CONN_MAX_AGE\": conn_max_age,\n            \"CONN_HEALTH_CHECKS\": conn_health_checks\n        }\n    )\n\n    for key, values in query.items():\n        if url.scheme == \"mysql\" and key == \"ssl-ca\":\n            options[\"ssl\"] = {\"ca\": values[-1]}\n            continue\n\n        options[key] = values[-1]\n</code></pre> <p>Support for Postgres Schema URLs</p> <pre><code>    if \"currentSchema\" in options and engine == \"django.db.backends.postgresql\":\n        options[\"options\"] = \"-c search_path={0}\".format(options.pop(\"currentSchema\"))\n\n    if options:\n        config[\"OPTIONS\"] = options\n\n    if engine:\n        config[\"ENGINE\"] = engine\n\n    return config\n</code></pre>"},{"location":"dauto/polymorphic/","title":"Polymorphic","text":"<pre><code>import typing\nfrom django.db.models import deletion, Model\nfrom contextlib import contextmanager\nfrom .utils.using import using\n\n\ndef polymorphic(model: Model, *_serializers: str, resourcetype_name=\"resourcetype\"):\n</code></pre> Docstring <p>Create a polymorphic serializer using already defined serializers over the related models</p> <p>Parameters: model: The parent model *_serializers: List of serializers to use resourcetype_name: The name of the resource type in the resulting polymorphic serializer</p> Warning <p>We need to check if polymorphic packages are installed</p> <p></p> <pre><code>    try:\n        from rest_polymorphic.serializers import PolymorphicSerializer\n    except ImportError as e:\n        raise ImportError(\"You must install dauto[polymorphic-rest] package to use this package.\")\n\n    final_klass_name = f\"{model.__class__.__name__}PolymorphicSerializer\"\n    classes = [using(s) for s in _serializers]\n    return type(\n        final_klass_name,\n        (PolymorphicSerializer,),\n        {\n            \"resource_type_field_name\": resourcetype_name,\n            \"model_serializer_mapping\": {\n                k.Meta.model: k for k in classes  # type\n            },\n        },\n    )\n\n\n@contextmanager\ndef collector(klass: typing.Type[deletion.Collector]):\n</code></pre> Docstring <p>This method monkey patch the collect method in an admin class in certain context to use polymorphic complaints operations over the related models</p> Warning <p>We need to check if polymorphic packages are installed</p> <pre><code>    try:\n        from polymorphic.models import PolymorphicModel\n    except ImportError as e:\n        raise ImportError(\"You must install dauto[polymorphic-model] package to use this package.\")\n\n    original = getattr(klass, \"collect\")\n\n    def custom(self, objs, source=None, source_attr=None, **kwargs):\n        if len(objs) &gt; 0 and isinstance(objs[0], PolymorphicModel):\n            for o in objs:\n                original(self, [o], source=None, source_attr=None, **kwargs)\n        else:\n            original(self, objs, source=None, source_attr=None, **kwargs)\n\n    klass.collect = custom\n    yield\n    klass.collect = original\n</code></pre>"},{"location":"dauto/signals/","title":"Signals","text":"<p>Signals and circular calls sucks and when we use signals this happen frequently then we made a method for execute code  without a signal. This work with a python contex manager used as a pun so:</p> <pre><code>with OutSignal(signal,sender, receiver):\n    &lt;code&gt;\n</code></pre> <p>Will execute the <code>code</code> section with the signal unplugged, avoiding circular imports and nested signal calls</p> <p></p> <pre><code>class OutSignal:\n</code></pre> Docstring <p>This class represents a context manager for disconnecting and reconnecting signal handlers.</p> <pre><code>    def __init__(self, signal, receiver, sender, dispatch_uid=None):\n</code></pre> Docstring <p>Initializes an instance of the OutSignal class.</p> <p>Parameters: - signal: The signal object to be disconnected and reconnected. - receiver: The receiver object whose signal handler will be disconnected and reconnected. - sender: The sender object that will trigger the signal handler. - dispatch_uid: An optional unique identifier for the signal handler. If provided, only the signal handler with matching dispatch_uid will be disconnected and reconnected.</p> <pre><code>        self.signal = signal\n        self.receiver = receiver\n        self.sender = sender\n        self.dispatch_uid = dispatch_uid\n\n    def __enter__(self):\n        self.signal.disconnect(\n            receiver=self.receiver,\n            sender=self.sender,\n            dispatch_uid=self.dispatch_uid\n        )\n</code></pre> <pre><code>    def __exit__(self, type, value, traceback):\n        self.signal.connect(\n            receiver=self.receiver,\n            sender=self.sender,\n            dispatch_uid=self.dispatch_uid\n        )\n</code></pre>"},{"location":"dauto/drf/__init__/","title":"Django Rest Framework","text":"<p>Now more than ever APIS are fashionable with microservices, lambdas, serverless functions etc, and the framework (all least one of then ) for make APIS using Django is the Django Rest Framework. Thi section cover a sets of class extensions to this framework to solve common issues.</p> Warning <p>We need to check if djangorestframework package is installed</p> <pre><code>try:\n    import rest_framework\nexcept ImportError as e:\n    raise ImportError(\"You must install dauto[rest] packages to use this package.\")\n</code></pre>"},{"location":"dauto/drf/permission/","title":"Permissions","text":"<pre><code>import typing\nfrom django.db import models\nfrom rest_framework import permissions, exceptions\n\nM = typing.TypeVar(\"M\", bound=models.Model)\n</code></pre> <p>We want to add a more fancy way of adding model permission to a function base view in python. Starting for a class that use a model as a pivot to get the requiere permissions</p> <p></p> <pre><code>class _BaseApiFunctionViewModelPermissions(permissions.BasePermission):\n    model = None\n\n    perms_map = {\n        \"GET\": [],\n        \"OPTIONS\": [],\n        \"HEAD\": [],\n        \"POST\": [\"%(app_label)s.add_%(model_name)s\"],\n        \"PUT\": [\"%(app_label)s.change_%(model_name)s\"],\n        \"PATCH\": [\"%(app_label)s.change_%(model_name)s\"],\n        \"DELETE\": [\"%(app_label)s.delete_%(model_name)s\"],\n    }\n\n    authenticated_users_only = True\n\n    def get_required_permissions(self, method):\n</code></pre> Docstring <p>Given a models and an HTTP method, return the list of permission codes that the user is required to have.</p> <pre><code>        kwargs = {\n            \"app_label\": self.model._meta.app_label,\n            \"model_name\": self.model._meta.model_name,\n        }\n\n        if method not in self.perms_map:\n            raise exceptions.MethodNotAllowed(method)\n\n        return [perm % kwargs for perm in self.perms_map[method]]\n\n    def has_permission(self, request, view):\n</code></pre> <p>Workaround to ensure DjangoModelPermissions are not applied to the root view when using DefaultRouter.</p> <pre><code>        if getattr(view, \"_ignore_model_permissions\", False):\n            return True\n\n        if not request.user or (\n                not request.user.is_authenticated and self.authenticated_users_only\n        ):\n            return False\n\n        perms = self.get_required_permissions(request.method)\n\n        return request.user.has_perms(perms)\n</code></pre> <p>and then a function that can build other permission classes (not instances) using the previous class as base and the model as a parameter</p> <p></p> <pre><code>def permissions_for(model: typing.Generic[M]) -&gt; type:\n</code></pre> Docstring <p>Create a dynamic permission class for the given model.</p> <p>Parameters: model: The model object for which the permissions class is being generated.</p> <p>Returns: type: The dynamically created permission class.</p> <pre><code>    return type(\n        f\"{model.__class__.__name__}ModelPermission\",\n        (_BaseApiFunctionViewModelPermissions,),\n        locals(),\n    )\n</code></pre>"},{"location":"dauto/drf/serializers/","title":"dauto.drf.serializers","text":"<pre><code>import typing\nfrom rest_framework import serializers\n</code></pre> <p>Some times we want to sort the fields of a serializer alphabetically to make it easier to read</p> <p></p> <pre><code>class AlphaSortedFieldsSerializer(serializers.Serializer):\n</code></pre> Docstring <p>Serializer that sorts fields alphabetically. Order first 'url' and 'id' fields typically resources identifiers</p> <pre><code>    sorted_first_fields: typing.Iterable[str] = (\"url\", \"id\")\n\n    def sort_fields(self, representation: typing.Dict[str, typing.Any]) -&gt; dict:\n</code></pre> Docstring <p>Sort representation keys alphabetically. Place first those fields in sorted_first_fields prop, by default identity fields ('id' and 'url') and last meta fields (starting with '_')</p> <p>:param representation: default :return: sorted dict</p> <p>Sort the fields alphabetically by key</p> <pre><code>        sorted_representation = OrderedDict(sorted(representation.items()))\n</code></pre> <p>Extract sorted fists fields</p> <pre><code>        sorted_first_dict = {\n            field: sorted_representation.pop(field)\n            for field in self.sorted_first_fields\n            if field in sorted_representation\n        }\n</code></pre> <p>Extract meta fields</p> <pre><code>        meta_fields_dict = {\n            field: sorted_representation.get(field)\n            for field in representation\n            if field.startswith(\"_\") or field == \"meta\"\n        }\n\n        if sorted_first_dict:\n            sorted_representation = {**sorted_first_dict, **sorted_representation}\n\n        if meta_fields_dict:\n            for field in meta_fields_dict:\n                sorted_representation.pop(field)\n            sorted_representation = {**sorted_representation, **meta_fields_dict}\n\n        return sorted_representation\n\n    def to_representation(self, instance):\n        return self.sort_fields(super().to_representation(instance))\n</code></pre>"},{"location":"dauto/drf/versioning/","title":"Versioning","text":"<pre><code>from rest_framework.versioning import NamespaceVersioning\n</code></pre> <p>A namespace versioning to use when we want split into version an API</p> <p></p> <pre><code>class CustomNamespaceVersioning(NamespaceVersioning):\n</code></pre> Docstring <p>This class extends the NamespaceVersioning class and provides a custom implementation for versioning view names in a web application.</p> <pre><code>    separator: str | None = None\n</code></pre> <pre><code>    def get_versioned_viewname(self, viewname: str, request):\n        assert self.separator is not None\n        if self.separator in viewname:\n            view, version = viewname.split(self.separator, maxsplit=1)\n            return f\"{version}:{view}\"\n        return super().get_versioned_viewname(viewname, request)\n</code></pre>"},{"location":"dauto/drf/viewsets/mixin/","title":"Mixins","text":"<pre><code>from rest_framework import mixins, status, viewsets\nfrom rest_framework.response import Response\n</code></pre> <p>Django use mixins as a sort of dependency injection or inversion of control. This file contain a set of these dependencies implementations beforehand.</p>"},{"location":"dauto/drf/viewsets/mixin/#serializer-mixins","title":"Serializer mixins","text":"<p>The serializer mixins can 'inject' new ways to get serializers from classes, can be combined between them. They are self documented</p> <p></p> <pre><code>class ByOperationSerializerMixin:\n</code></pre> Docstring <p>This class is responsible for determining the appropriate serializer class based on the HTTP request method and the action being performed. It extends the GenericViewSet class.</p> <p></p> <pre><code>    def get_serializer_class(self: viewsets.GenericViewSet):\n        old: dict = super().get_serializer_class()\n        if hasattr(self, \"action\") and self.action in old:\n            return old.get(self.action)\n        elif self.request.method in [\"GET\", \"HEAD\", \"OPTIONS\"]:\n            return old.get(\"read\")\n        return old.get(\"write\")\n\n\nclass ByVersionSerializerMixin:\n</code></pre> Docstring <p>This class is responsible for determining the appropriate serializer class based on the request version.</p> <pre><code>    def get_serializer_class(self):\n        old: dict = super().get_serializer_class()\n        return old.get(self.request.version)\n</code></pre>"},{"location":"dauto/drf/viewsets/mixin/#verbose-mixins","title":"Verbose mixins","text":"<p>Many times we want a more verbose output from a write method (create, update, partial update) when we use DRF. The verbose mixins classes can do it using a read serializer to map the target instance into the desired format.</p> <p></p> <pre><code>class CreateVerboseModelMixin(mixins.CreateModelMixin):\n</code></pre> Docstring <p>This class is a mixin that extends the functionality of the CreateModelMixin class. It provides additional</p> <pre><code>    def get_read_object(self, instance):\n        return instance\n\n    def get_read_serializer(self, *args, **kwargs):\n</code></pre> Docstring <p>Return the serializer instance that should be used for validating and deserializing input, and for serializing output.</p> <pre><code>        method = self.request.method\n        self.request.method = \"GET\"\n        serializer_class = self.get_serializer_class()\n        self.request.method = method\n        kwargs.setdefault(\"context\", self.get_serializer_context())\n        return serializer_class(*args, **kwargs)\n\n    def create(self, request, *args, **kwargs):\n        serializer = self.get_serializer(data=request.data)\n        serializer.is_valid(raise_exception=True)\n        self.perform_create(serializer)\n        headers = self.get_success_headers(serializer.data)\n        read_serializer = self.get_read_serializer(self.get_read_object(serializer.instance))\n        return Response(\n            read_serializer.data, status=status.HTTP_201_CREATED, headers=headers\n        )\n</code></pre> <p></p> <pre><code>class UpdateVerboseModelMixin(mixins.UpdateModelMixin):\n</code></pre> Docstring <p>This class is a mixin that provides additional functionality for updating models with verbose output.</p> <pre><code>    def get_read_object(self, instance):\n        return instance\n\n    def get_read_serializer(self, *args, **kwargs):\n</code></pre> Docstring <p>Return the serializer instance that should be used for validating and deserializing input, and for serializing output.</p> <pre><code>        method = self.request.method\n        self.request.method = \"GET\"\n        serializer_class = self.get_serializer_class()\n        self.request.method = method\n        kwargs.setdefault(\"context\", self.get_serializer_context())\n        return serializer_class(*args, **kwargs)\n\n    def update(self, request, *args, **kwargs):\n        partial = kwargs.pop(\"partial\", False)\n        instance = self.get_object()\n        serializer = self.get_serializer(instance, data=request.data, partial=partial)\n        serializer.is_valid(raise_exception=True)\n        self.perform_update(serializer)\n        if getattr(instance, \"_prefetched_objects_cache\", None):\n</code></pre> <p>If 'prefetch_related' has been applied to a queryset, we need to forcibly invalidate the prefetch cache on the instance.</p> <pre><code>            instance._prefetched_objects_cache = {}\n        read_serializer = self.get_read_serializer(self.get_read_object(serializer.instance))\n        return Response(read_serializer.data)\n</code></pre>"}]}